---
title: "STAT547_hw06"
output: github_document
always_allow_html: yes
---

```{r}
library(tidyverse)
library(testthat)
library(gapminder)
library(broom)
```

# (1) Character data

For this prompt, I have selected some exercises from [R for Data Science](https://r4ds.had.co.nz/strings.html#other-types-of-pattern). I will subdivide this into three sections. (A) Miscellaneous exercises and (B) *Regular expressions* exercises, both from **R for Data Science**, and (C) A practical application of regex.

## (1-A) Miscellaneous

```{r}
#Describe the difference between the sep and collapse arguments to str_c().

str_c("a fox", "is not a bear", sep = ": ") #sep is useful with two independent strings
str_c(c("a fox", "is not a bear"), sep = ": ") #sep not so useful with a vector of strings
str_c(c("a fox", "is not a bear"), collapse = ": ") #collapse puts a vector of strings into one string, and separates by the specified argument
```

```{r}
#What does str_wrap() do? When might you want to use it?

s <- str_c(sentences[[1]], sentences[[2]], sentences[[3]], sep = " ") #Random paragraph

#str_wrap formats the text wrapping of the output
str_wrap(s, width = 30, indent = 5, exdent = 3) %>% writeLines()
```

```{r}
#What does str_trim() do? What’s the opposite of str_trim()?

str_trim("   Here is a poorly formatted sentence. It has a lot of white space.    ", side = "both")
#str_trim removes white space from a string, including tab and new lines.

str_pad("Here is a sentence to which I want to add white space.", width = 100)
#str_pad adds white space (or a specified string) until the width reaches the specified argument.
#I use 100 because it is longer than the sentence's character count
```

## (1-B) Regular Expressions

```{r}
#How would you match the sequence "'\?
x <- "\"\'\\"
str_view(x, "\"\'\\\\")
```

```{r}
#What patterns will the regular expression \\..\\..\\.. match? How would you represent it as a string?

x1 <- c("abc123", ".a.b.c", "......", ".\\.\\.\\")
str_view_all(x1, pattern = "\\..\\..\\..")
#"\\.." as a regex finds a literal dot, then anything. Repeat thrice.
```


```{r}
#How would you match the literal string "$^$"?

str_view("$^$", pattern = "\\$\\^\\$")
#similar to finding a literal dot, need two backslashes
```


```{r}
#Given the corpus of common words in stringr::words, create regular expressions that find all words that:

#Start with “y”.
str_view(words, "^y", match = TRUE)

#End with “x”
str_view(words, "x$", match = TRUE)

#Are exactly three letters long.
str_view(words, "^...$", match = TRUE)

#Have seven letters or more.
str_view(words, "^.......", match = TRUE)
```


```{r}
wordSet <- c("alphabet", "Pangea", "zebra", "STAT547", "escape", "tweed", "bed", "wise", "thing")

#Create regular expressions to find all words that:

#Start with a vowel.
str_view(wordSet, pattern = "^[aeiou]", match = TRUE)

#That only contain consonants. (Hint: thinking about matching “not”-vowels.)
str_view(wordSet, pattern = "^[^aeiou]", match = TRUE)

#End with ed, but not with eed.
str_view(wordSet, pattern = "[^e]ed$", match = TRUE)

#End with ing or ise.
str_view(wordSet, pattern = "(ing)|(ise)$", match = TRUE)

#Empirically verify the rule “i before e except after c”.
str_view(words, pattern = "(cie)|(cei)", match = TRUE)

#Is “q” always followed by a “u”?
str_view(words, pattern = "q[^u]", match = TRUE)

```

```{r}
#Write a regular expression that matches a word if it’s probably written in British English, not American English.

#look for words that end in "re" (instead of "er" in American English)
#exclude words that have vowels before "re"
str_view(words, pattern = "[^aeiou]re$", match = TRUE)
```


```{r}
#Create a regular expression that will match telephone numbers as commonly written in your country

phoneNumbers <- c("1-800-123-4567", "604-123-4567", "911", "0123456789")

str_view(phoneNumbers, pattern = "^\\d\\d\\d\\-\\d\\d\\d\\-\\d\\d\\d\\d$")
```

```{r}
#Describe the equivalents of ?, +, * in {m,n} form.

x2 <- c("aaa", "aab", "aaaabb", "b")

#equivalent to '?'
str_view(x2, "a{0,1}")

#equivalent to '+'
str_view(x2, "b{1,}")

#equivalent to '*'
str_view(x2, "a{0,}")
```


```{r}
#Describe in words what these regular expressions match:

# regex ^.*$
str_view("aa", "^.*$")

# string "\\{.+\\}"
str_view("\\{.+\\}", "\\\\\\{\\.\\+\\\\\\}")

# regex \d{4}-\d{2}-\d{2}
str_view("1234-56-78", "\\d{4}-\\d{2}-\\d{2}")

# string "\\\\{4}"
str_view("\\\\{4}", "\\\\\\\\\\{\\d\\}")

```


```{r}
#Create regular expressions to find all words that

x3 <- c("zxcv", "uiop", "Aei", "apart")

#Start with three consonants.
str_view(x3, "^[^aeiou][^aeiou][^aeiou]")

#Have three or more vowels in a row.
str_view(x3, "[AEIOUaeiou][aeiou][aeiou]")

#Have two or more vowel-consonant pairs in a row.
str_view(x3, "([AEIOUaeiou][^aeiou][aeiou][^aeiou])")

```

```{r}
#Construct regular expressions to match words that:

#Start and end with the same character.
str_view("racecar", "^(.).{0,}\\1$")

#Contain a repeated pair of letters
str_view("church", "(.)(.).{0,}\\1\\2")

#Contain one letter repeated in at least three places
str_view("eleven", "(.).{0,}\\1.{0,}\\1")
```

## (1-C)

In this section, I use regex and some `stringr` functions to demonstrate how these could be useful in my research. This exercise has been adapted from *R for Data Science*.

```{r}

zxcv <- c("Energy policy is critical, especially battery storage",
          "Wind energy has increased x-fold in the past year.",
          "Is nuclear dead? Researchers say no. Fusion is around the corner.",
          "This sentence has none of the words.")

word_set <- c("[Ee]nergy", "[Pp]olicy", "[Ss]olar", "[Ww]ind", "[Bb]atter(y|ies)", "[Nn]uclear")

(word_set_match <- str_c(word_set, collapse = "|"))

(has_match <- str_subset(zxcv, word_set_match))

(matched_words <- str_extract_all(has_match, word_set_match))

(matches <- zxcv[str_count(zxcv, word_set_match) >= 1])
str_view_all(matches, word_set_match)

```


# (2) Writing functions

For this prompt, I have written a function that does a linear regression. I will then use this for prompt #6.

The function takes a vector 'A' and fits a linear regression with `lm()` for 'x' and 'y'. `glance()` returns a useful one-row statistical summary from the `broom` package.

```{r}
linearFit <- function(A, x, y) {
  fit <- lm(A[[y]] ~ A[[x]], data = A) %>% 
    glance()
}

quadFit <- function(A, x, y) {
  fit <- lm(A[[y]] ~ A[[x]] + (A[[x]])^2, data = A) %>% 
    glance()
}


quadFit2 <- function(A) {
  fit <- lm(lifeExp ~ I(year - 1952) + I((year - 1952)^2), data = A) %>% 
    glance()
}

linearFit2 <- function(A) {
  fit <- lm(lifeExp ~ I(year - 1952), data = A) %>% 
    glance()
}

#Test function with a simple case:

test_tibble <- tibble(
  "qwerty" = c(1,2,3),
  "uiop" = c(4,5,7),
  "not_used" = c(8,9,11)
)

r_sq_lm <- lm(qwerty ~ uiop, test_tibble) %>% glance() %>% select("r.squared")

r_sq_linearFit <- (linearFit(test_tibble, "qwerty", "uiop") %>% select("r.squared"))

test_that("Simple case works.",
          expect_equal(r_sq_linearFit, r_sq_lm)
          )
```


# (6) Work with a nested data frame

For this prompt, I use the functions built in prompt #2 to fit regression models to life expectancy data in the 'gapminder' dataframe.

```{r}
#Nest gapminder data by country
gap_nest <- gapminder %>% nest(-country)

#Fit a linear regression to each country
(gap_fit <- gap_nest %>% 
    mutate(fit = map(gap_nest$data, linearFit2))
)

#Get desired output (r.squared values for each country) in tibble form
(gap_Rsq <- gap_fit %>% 
    select(country, fit) %>% 
    unnest() %>% 
    select(country, r.squared)
)

#Check for countries with less than 10% r.squared value
(filter(gap_Rsq, r.squared < 0.1))

#Create a character string for countries that match <10% r.squared value
(poor_matches <- filter(gap_Rsq, r.squared < 0.1) %>% 
  select(country) %>% 
  #lapply(., as.character) %>% 
  unlist() %>% 
  paste(collapse = "|")
)

#Plot the countries with low r.squared values
gap_nest %>% unnest() %>%
  filter(grepl(poor_matches, country)) %>% 
  ggplot(aes(year, lifeExp)) +
    geom_point() +
    geom_smooth(method = lm, se = FALSE) +
    facet_wrap(~country) +
    theme_classic()

```


```{r}
#Repeat for quadratic regression
gap_fitQ <- gap_nest %>% mutate(fit = map(gap_nest$data, quadFit2))

(gap_RsqQ <- gap_fitQ %>% 
    select(country, fit) %>% 
    unnest() %>% 
    select(country, r.squared))

#Compare r.squared values of quadratic vs. linear regression
gap_compare <- gap_RsqQ %>% filter(grepl(poor_matches, country)) %>% 
  left_join(gap_Rsq, by = "country") %>% 
  rename("r.squared\n(quadratic)" = "r.squared.x",
         "r.squared\n(linear)" = "r.squared.y")
gap_compare
```


#references
https://stackoverflow.com/questions/2641653/pass-a-data-frame-column-name-to-a-function
https://www.theanalysisfactor.com/r-tutorial-4/
http://stat545.com/block012_function-regress-lifeexp-on-year.html
https://awakeningdatascientist.wordpress.com/2015/07/20/r-of-the-day-grep-and-grepl/
